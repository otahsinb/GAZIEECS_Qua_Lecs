<div align="center" id="top"> 
  <img src="./ftry.jpg" alt="insallah" />

  &#xa0;

</div>

<h1 align="center">Doktora Yeterlik Sınavı Çalışma Alanı</h1>

<p align="center">
  <img alt="Github top language" src="https://img.shields.io/github/languages/top/otahsinb/GAZIEECS_Qua_Lecs">

  <img alt="Github stars" src="https://img.shields.io/github/stars/otahsinb/GAZIEECS_Qua_Lecs" />

  <img alt="License" src="https://img.shields.io/github/license/otahsinb/GAZIEECS_Qua_Lecs">

  <!-- <img alt="Github issues" src="https://img.shields.io/github/issues/otahsinb/GAZIEECS_Qua_Lecs" /> -->

  <!-- <img alt="Repository size" src="https://img.shields.io/github/repo-size/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github language count" src="https://img.shields.io/github/languages/count/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github forks" src="https://img.shields.io/github/forks/0otahsinb/GAZIEECS_Qua_Lecs" /> -->

</p>


<p align="center">
  <a href="#dart-00-açıklama">00 Açıklama</a> &#xa0; | &#xa0; 
  <a href="#sparkler-01-veri-yapıları">01 Veri Yapıları</a> &#xa0; | &#xa0;
  <a href="#octocat-02-algoritmalar">02 Algoritmalar</a> &#xa0; | &#xa0;
  <a href="#surfer-03-ayrık-matematik">03 Ayrık Matematik</a> &#xa0; | &#xa0;
  <a href="#dizzy-04-bilgisayar-ağları">04 Bilgisayar Ağları</a> &#xa0; | &#xa0;
  <a href="#art-05-işletim-sistemleri">05 Işletim Sistemleri</a> &#xa0; | &#xa0;
  <a href="#twisted_rightwards_arrows-06-sayısal-tasarım">06 Sayısal Tasarım</a> &#xa0; | &#xa0;
  <a href="#fish_cake-07-yazılım-mühendisliği">07 Yazılım Mühendisliği</a> &#xa0; | &#xa0;
  <a href="#dvd-08-veritabanı">08 Veritabanı</a> &#xa0; | &#xa0;
  <a href="#factory-09-bilgisayar-mimarisi">09 Bilgisayar Mimarisi</a> &#xa0; | &#xa0;
  <a href="#sparkles-10-yapay-zeka">10 Yapay Zeka</a> &#xa0; | &#xa0;
  <a href="#memo-lisans">Lisans</a> &#xa0; | &#xa0;
  <a href="https://github.com/otahsinb" target="_blank">Yazar</a>
</p>

<br>

## :dart: 00 Açıklama ##

 Bu alan bilgisayar bilimleri doktora yeterlik sınavı notlarını kaydetme amacıyla kendim için açtığım bir alandır. Burada yeterlik sınavında sorumlu olunan derslerin notlarını bulabilirsiniz.
 
 ```bash
# Clone this project
$ git clone https://github.com/otahsinb/GAZIEECS_Qua_Lecs

# Access
$ cd GAZIEECS_Qua_Lecs

# Run the project

```
 
:heavy_check_mark: Dersler ve Konu Başlıkları \
:heavy_check_mark: Linkler \
:heavy_check_mark: Kullanışlı Araçlar\
:heavy_check_mark: Sınavlar\
:heavy_check_mark: Notlar

<a href="#top">Back to top</a>

## :sparkler: 01 Veri Yapıları ##
 
  ```sh
    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 
  ```

<details>
  
  <summary> Çıkmış Sorular </summary> <br />
  
  :musical_score: C++20 Cheatsheet (Veri Yapıları ile İlgili Detaylı Bilgi Bulabilirsin...🡓🡓🡓)
  ```sh
  https://hackingcpp.com/cpp/cheat_sheets.html
  ```
  
</details>

<a href="#top">Back to top</a>

## :octocat: 02 Algoritmalar ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :surfer: 03 Ayrık Matematik ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :dizzy: 04 Bilgisayar Ağları ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 



<details>
  
  <summary> Notlar </summary> <br />
  


 :dizzy: :dizzy: Uç sistemler birbirine iletişim linkleri ve paket anahtarlar ile bağlanır. Farklı iletişim linkleri farklı iletim oranına (transmission rate) sahiptir (bps). Gönderici veriyi parçalara böler, her parçaya başlık bilgisi ekler. Elde edilen veri parçasına paket denir. 
  
  :dizzy: :dizzy: Paket anahtar veriyi bir girişten alır, başka çıkışa yönlendirir. İnternet’te, paket anahtar olarak router ve link-layer switch kullanılır. Link-layer switch erişim ağlarında (access networks), router ağın temel (network core) kısmında kullanılır. Bir paket, göndericiden alıcıya bir dizi linki (route, path) kullanarak ulaşır. Uç sistemler, İnternet Servis Sağlayıcı (İSS) üzerinden İnternet’e bağlanır. Uç sistemlerde, paket anahtarlarda ve diğer bileşenlerde veri göndermek ve almak için protokol çalıştırılır.
  
  :dizzy: :dizzy: Transmission Control Protocol (TCP) ve Internet Protocol (IP), İnternet’teki en önemli iki protokoldür. İnternet’te kullanılan protokol kümesi TCP/IP olarak adlandırılır. Birbiriyle çalışabilen sistemler oluşturmak için standartlar gereklidir. İnternet standartları Internet Engineering Task Force (IETF) tarafından geliştirilir. IETF standartları Request For Comments (RFCs) olarak adlandırılır. Institute of Electrical and Electronics Engineers (IEEE) 802 LAN/MAN standart grubu Ethernet ve Wi-Fi standartlarını belirler. 
  
  :dizzy: :dizzy: Uç sistemler, Application Programming Interface (API) kullanılarak, Java, C++, Phyton gibi yüksek seviyeli dillerle geliştirilir. İnternet API, veriyi gönderme, taşıma ve alıcı tarafından alınması ile ilgili kurallar kümesidir. 
  
  :dizzy: :dizzy: Ağ protokolleri, insanların kullandığı protokollere benzer. İnternet’teki tüm iletişim protokollerle yapılır. Karşılıklı iletişim yapan birimler aynı protokolü kullanmalıdır. Donanımsal (hardware-implemented) protokoller ağ arayüz (network interface) kartlarında bulunur ve iki bilgisayar arasında bit akışını gerçekleştirir. Ağ protokolleri, tıkanıklık denetimi (host), akış denetimi (host), sıralama (host), paketlerin izleyeceği yolun belirlenmesi (router) gibi tüm işleri yapar. 
  
  :dizzy: :dizzy: Bir protokolün üç bileşeni var: syntax, semantic, timing. İki veya daha fazla birim arasında gönderilen mesajların formatını ve sırasını tanımlar. Bir mesaj gönderildiğinde/alındığında ne yapılacağını belirler. Bir mesajın cevabı bekleniyor ve gelmediyse ne yapılacağını belirler. İletişim kaynağının maksimum verimle kullanılması için gerekli düzenlemeleri yapar. 
  
  :dizzy: :dizzy: İnternet uç sistemleri, çok sayıda heterojen cihazı içerir. Uygulama programları uç sistemler (host) üzerinde çalışır. İnternet’te iki tür host vardır: İstemci (Client) ve Sunucu (Server). 
  
  :dizzy: :dizzy: Erişim ağı, uç sistemi ilk router’a (edge router) bağlayan ağdır. Erişim ağları, uç sistemleri ilk router’a bağlayan linkleri ve altyapıyı sağlar. Erişim ağları, konut erişimi, kurumsal erişim veya kablosuz erişim için kullanılır. 
  
  :dizzy: :dizzy: Konutlardan genişbant erişim çoğunlukla Digital Subcriber Line (DSL) ve Cable ile yapılmaktadır. DSL ile erişimde telefon şirketi İnternet servis sağlayıcısıdır. Konuttaki DSL modem, telco’da (telephone company) bulunan DSLAM (Digital Subscriber Line Access Multiplexer) ile veri alışverişi yapar. Çok sayıda konuttan gelen analog sinyaller DSLAM’de sayısal formata dönüştürülür. 

<a href="#top">Back to top</a>

</details>

## :art: 05 Işletim Sistemleri ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :twisted_rightwards_arrows: 06 Sayısal Tasarım ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :fish_cake: 07 Yazılım Mühendisliği ##

    .
    ├── Software Engineering Methods
    ├── Software Development Processes
    ├── System modeling, context models, Interaction models, Structural models
    ├── Software Requirements
    ├── Software Modelling
    ├── Behavioral models, model-driven engineering
    ├── Prototyping
    ├── Software Design and Representation
    ├── User Interface Design
    ├── Software Testing
    ├── Software Project Management
    ├── Software Quality Assurance
    └── Software Process Improvement

<details>
<summary> Çıkmış Sorular </summary>

**Q1:**
The stages of the software development lifecycle (SDLC):\
Ans: P-A-D-I-T-D-M\
:maple_leaf: Yazılım Geliştirme Yaşam Döngüsünün aşamaları:

Aşamalar  | Açıklamalar
------------- | -------------
1- Planlama:     | Defining the goals, scope, and constraints of the project.
2- Analiz:       | Gathering and documenting requirements for the software.
3- Tasarım:      | Creating a plan for the structure and functionality of the software.
4- Implementasyon:       | Writing and testing the code for the software.
5- Testing:     | Evaluating the software to ensure it meets the requirements and is of high quality.
6- Deployment:       | Making the software available for use in a production environment.
7- Maintenance:     | Ongoing support, bug fixes, and updates for the software.

**Q2:**
:maple_leaf: Yazılım Geliştirme'de accidental ve essential complexity arasındaki ilişkiyi açıklayınız:

Kavram  | Açıklamalar
------------- | -------------
1- Accidental complexity:               | Yazılım geliştirme sürecinde kullanılan araç ve teknolojilerin etkisi ile ortaya çıkan karmaşıklıktır. (Refers to the complexity that arises due to the limitations of the tools and techniques used to build the software. )
2- Essential complexity:                | Yazılım geliştirme sürecinde yazılım tarafından çözülen problemden kaynaklanan kalıtsal karmaşıklıktır. (Refers to the inherent complexity of the problem being solved by the software)
3- Relation between A&E complexity:     | **No silver bullet veya no single technique veya araç** yaklaşımı ile yazılım geliştirmedeki karmaşıklığı azaltabileceğimiz belirtilmektedir. Bu yaklaşımda 1- Yüksek seviye programalama dillerinin kullanılması ve daha güçlü bilgisayarların kullanılması daha etkili ve etkin yollar ile accidental karmaşıklığı azaltabilir. 2- Moduler tasarımlar ile yazılım daha küçük parçalara ayrılarak daha kolay yönetilebilir. 3- Daha sistematik yaklaşımlar ile örneğin test ve debug araçları kullanarak karmaşıklık azaltılabilir. Özetle yazılım geliştirme süreçlerindeki karmaşıklığı azaltmak ve üretkenliği artırmak için daha iyi araçlar, teknikler ve sistematik prensiplere yönelmek gerekmektedir. (**No silver bullet – no single technique or tool** that can significantly reduce the essential complexity of software development. However, he does identify some promising approaches for improving how we build software, including: 1- Using higher-level programming languages and more powerful computers, which can help reduce accidental complexity by providing more expressive and efficient ways of solving problems. 2- Using modular design and structured programming techniques to break down complex systems into smaller, more manageable pieces. 3- Adopting a rigorous and systematic approach to software development, including the use of testing and debugging tools and practices. Overall, the key to improving software development is to focus on reducing accidental complexity and increasing the productivity and effectiveness of developers. This can be achieved through the use of better tools and techniques, as well as through the adoption of sound engineering practices and principles.)

**Q3:**
:maple_leaf: Describe briefly what distinguishes the "agile" approaches to software development from more traditional approaches. Identify at least two of the reasons
behind the agile approaches described by Fowler in his "The New Methodology" article:

**Q4:**
:maple_leaf: Describe briefly what we mean by the terms coupling and cohesion:

**Q5:**
:maple_leaf: Describe briefly what we mean by the term software architecture. Give an example of at least one architectural style from our readings:

**Q6:**
:maple_leaf: Describe briefly what we mean by the term design pattern. Give two examples of design patterns from our readings:

**Q7:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q8:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q9:**
:maple_leaf: Choose three of these design principles. For each, either describe it briefly or give an example that illustrates it.

• Single Responsibility Principle: \
• Open-Closed Principle: \
• Liskov's Substitution Principle: \
• Dependency Inversion Principle: \
• Interface Segregation Principle:

**Q10:**
:maple_leaf: Draw a simple UML class diagram that shows the relationships among customers who place orders for various kinds of office supplies from a retail store. The store serves both individuals and corporate clients. Payments are made via cash, credit, and invoice.


**Q11**
:maple_leaf: Name and define (in the context of software engineering) one desirable software quality, other than “maintainability” and “correctness,”

**Q12**
:maple_leaf: software process model nedir? Örnekler ile açıklayınız.

**Q13**
:maple_leaf: explain processes of requirements engineering.

**Q14**
:maple_leaf: explain Extreme Programming practices.

**Q15** 
:maple_leaf: Why is the waterfall model called an “ideal” model?
Short Answer: It represents the software process as having no imperfections.

**Q16**
:maple_leaf: Draw a UML class diagram (chapter 5, slide 9) representing a book defined by the following statement: “A book is composed of a number of parts, which in turn are composed of a number of chapters. Chapters are composed of sections.” Focus only on classes and relationships.  Add multiplicity to the class diagram you produced.

**Q17**
:maple_leaf: List and describe (using at least one sentence each) the three types of software maintenance.  Which one of the three typically gets over half (65%) of the maintenance effort?  (in other words, more time is spent on this type of maintenance). Why?

**Q18**
:maple_leaf: List and describe at least three techniques for deriving test cases (for any kind of software testing).  Your answer should have at least three sentences (at least one for each technique).

**Q19**
:maple_leaf: Draw a class diagram showing the structure of data about employees of a given company.  The employees attributes include name, street address, city, state, zip, and an id number.  The employees also have an annual salary.  Departments have names and are composed of a collection of employees, but each employee can be in only one department.  Employees work on one or more projects, which also have names.  Projects may have multiple employees assigned to them. Include multiplicity, and attributes in your diagram. 

**Q20**
:maple_leaf: Given the UML class diagram on the next page decompose it into a set of components (subsystems) that has at least 2 (but no more than 4) components. Use the goals of loose coupling and high cohesion (and any other heuristics that may apply) for deciding which classes should go in each component.


<img src="./or1.PNG" alt="or1" />

**Q21**
:maple_leaf: Draw a control flow diagram for the following source code:  Then:
•assign a number to each node.
•list the unique paths through the control flow diagram (use a sequence of node numbers to identify each path).
•for each unique path, generate a test case by giving values to use for a, b, and c to make the program run through that path. Also give the expected result (the value of d). 

> d = 0;
> 
> if (a > b);
> 
>> d = d+1;
>> 
> if (b > c);
> 
>> d = d+2;
>> 
> cout << d << endl;


**Q22**
:maple_leaf: Test a method called “verifyPassword” that takes a string representing a proposed password, and returns true if it meets the following criteria (and false if it doesn’t):
•at least 7 characters •at least one digit
•at least one uppercase letter Identify at least 5 testing partitions for this function, and derive a set of test cases (one for each partition).  Be sure to include the test data value(s) and expected result(s) for each test case.

**Q23**
:maple_leaf: Develop a set of use case diagrams (with one-sentence textual descriptions) to describe the requirements for a university scheduling system that manages the university’s course offerings, including students registering for courses. You should include at least 3 actors. Each actor should have at least one use case that is unique. You should have at least 5 use cases (interactions).

**Q24**
:maple_leaf: Design and draw the basic architecture of a video chess game that can be played on a smart phone using one of the architectural design patterns from chapter 6 (indicate in your answer which pattern you are using). The current state of the game board should be able to be viewed in 2D or 3D or even in a text format (suitable for e-mailing). The user can move pieces by touching and dragging the pieces on the screen. The moves may be animated (or not).


**Q25**
:maple_leaf: List and describe three methods or tools used during requirements development (in any of the four sub-disciplines). How does each method contribute to the goal of developing requirements specifications of good quality?


**Q26**
:maple_leaf: Choose 3 of the 12 core practices of Extreme Programming (XP) and give a brief description of each. For each one indicate what benefit it provides over more traditional development methods (assuming it is used in the context of agile development).


**Q27**
:maple_leaf: Give an example of a design pattern whose use is obvious from a class diagram but not from a sequence diagram. (Don’t choose one that is built into (some) programming languages, such as inheritance.) Explain why, in 1 sentence.

Short Ans: Composite: the members of a class are of a type that allows similar operations (perhaps they implement an interface in common with the container class). Observer: especially easy if there’s an hobservesi notation on an arrow. For many patterns it’s possible to argue either way (and we were looking for your argument, not just a name). A common pitfall here was conflating class and object diagrams.


**Q28**
:maple_leaf: Give an example of a design pattern whose use is obvious from a sequence diagram but not from a class diagram. (Don’t choose one that is built into (some) programming languages, such as iteration.) Explain why, in 1 sentence.

Short Ans : Factory: an actor creates an object in response to a call, and the caller subsequently sends messages to the newly created object. Decorator: every message to the decorator object is followed by a call to the object it decorates.


**Q29**
:maple_leaf: Consider two components A and B. Two software engineers, Laurel and Hardy, measure the dependences between A and B. Laurel uses these dependences when computing cohesion, and Hardy uses these dependences when computing coupling. Is this possible, if both engineers are performing a sensible and useful computation? In 1–2 sentences, explain why or why not.

SA: Yes. Laurel is considering a larger module C that contains both A and B as implementation details. Hardy is considering the implementation of C, and thinking of A and B as modules. 

**Q30**
:maple_leaf: Consider two components A and B. Two software engineers, Laurel and Hardy, measure the dependences between A and B. Laurel uses these dependences when computing cohesion, and Hardy uses these dependences when computing coupling. Is this possible, if both engineers are performing a sensible and useful computation? In 1–2 sentences, explain why or why not.
SA: Yes. Laurel is considering a larger module C that contains both A and B as implementation details. Hardy is considering the implementation of C, and thinking of A and B as modules.

**Q31**
:maple_leaf: In 1 sentence each, give two distinct reasons that you should not commit compiled code (such as .o or .class files) to a version control repository

SAs: Merge conflicts cannot be resolved. Another way of saying the same thing is that binary files are not diffable (by the standard text-based diff algorithms).\
Repetition of information in source and binary forms violates the DRY (don’t repeat yourself)
principle.\
Binary files such as .o files are architecture-dependent and may not be useful to others.\
Binary files may contain information such as timestamps that is guaranteed to create a conflict even if generated from the same source code by others.\
Bloat in the VCS because differences are huge.\
Timestamps might not be preserved.\
If there is a check-in without compiling, then they can be inconsistent with the source code.

**Q32**
:maple_leaf:  It is cheaper and faster to fix known bugs before you write new code. Why? In one phrase or sentence each, give three reasons. Give reasons that are as different from one another as possible.

SAs:\
• You are familiar with the code now. A related reason is that the bug will be harder to find and fix later.\
• Later code may depend on this code. A related reason is that a bug may reveal a fundamental problem.\
• Leaving all bugs to the end will make it harder to understand and keep to the schedule, because it’s hard to predict how long bug fixing will take.\
• An overfull bug database is demoralizing and is likely to be ignored.\
• You will be able to add tests for the bug once it’s been fixed to avoid future issues.\
• Avoid feature creep.


**Q33**
:maple_leaf: After you find a bug but before fixing it, you should create a test case for it. In one sentence each, give three reasons that this is a good idea. Give reasons that are as distinct as possible.

SAs:\

• Ensures that your fix solves the problem. Don’t add a test that succeeded to begin with! A related reason is to avoid writing a test for a bug that you fixed, but that isn’t the problem indicated by the original bug fix.\
• It helps you understand the bug and define the desired system behavior. (“It documents the bug” or “it informs others of the bug” is wrong, because it is the purpose of your bug tracking system to document your bugs. If you meant something different, such as the good answers listed here, then please be more specific.)\
• It helps you know when you are done with bug fixing. A related reason is repeatability, and efficiency when debugging: the test is easy to run in an automated way to determine whether your fix works.

Here are some more answers we accepted, even though they are really just reasons to write a test at all, and not reasons to write the test before you fix the bug:\
• Helps to populate test suite with good tests. The test case may reveal other problems also, that would make sense to fix at the same time.\
• Protects against reversions that reintroduce bug. It happened at least once, and it might happen again.


**Q34**
:maple_leaf: Consider a wrapper whose implementation logs each call that occurs. In no more than 2 sentences each, explain when the wrapper should be considered a decorator (and why), and when that same wrapper should be considered a proxy (and why).\

SAs:\

• Decorator: A decorator has different functionality but the same interface as the delegate. If the wrapper’s specification requires it to do the logging, then it should be considered a decorator.\
• Proxy: A proxy has the same functionality and the same interface as the delegate. If the wrapper has a lenient specification that permits but does not require it to perform logging, then it should be considered a proxy.\


**Q35**
:maple_leaf: ) Recall that the interning pattern guarantees that any two objects with the same abstract value are represented by just one concrete object. Answer each part in one sentence.\
(a) Give a usage pattern (or its characteristics) in which the interning pattern uses less memory, compared to not using it, and explain why.\
A: A compiler symbol table, in which most symbols are used multiple times, so eliminating duplication saves memory.\
(b) Give a usage pattern (or its characteristics) in which the interning pattern uses more memory, compared to not using it, and explain why.\
A: A situation in which most objects have different values, so the overhead of the hash table used by the interning implementation outweighs the reduction in memory used by duplicate objects.\
(c) Give a usage pattern (or its characteristics) in which the interning pattern uses less time, compared to not using it, and explain why. Ignore effects that are really due to memory use, such as faster allocation.\
A: Interning makes comparisons complete faster (the equals method always first checks object equality), so if there are many comparisons, the speedup outweighs the time cost of interning, which is a search for an equal object.\
(d) Give a usage pattern (or its characteristics) in which the interning pattern uses more time, compared to not using it, and explain why. Ignore effects that are really due to memory use, such as thrashing.\
A: If few equality checks are performed, then the speedup does not outweigh the time cost of performing interning. The main goal of interning is to save memory, so interning can be worthwhile even if it slows down the program.

**Q36**
:maple_leaf: Explain the difference between a self-call, a synchronous callback, and an asynchronous callback. Give a concrete example of each. Draw a sequence diagram for each, and explicitly mark the self-call or callback in each (one marked call in each).\

![C1](https://user-images.githubusercontent.com/54834769/210238054-6e6303c3-62f3-4d8a-a125-8ac244e647c3.JPG)
![C2](https://user-images.githubusercontent.com/54834769/210238080-7c89c836-a79c-4ad1-827c-c0478c774298.JPG)
![C3](https://user-images.githubusercontent.com/54834769/210238091-33ff7e09-993e-43ef-ba03-6611f8796c3e.JPG)



**Q37**
:maple_leaf: Waterfall modelini açıklayınız.
A: Gereksinim Analizi -> Sistem ve Yazılım Tasarımı -> Gerçekleme ve Birim Testler -> Entegrasyon ve Sistem Testleri -> Operasyon ve Sistem Devamlılığı\
Değişime karşı yavaş reaksiyon verilir.

**Q38**
:maple_leaf: Yazılım Mühendisliği nedir?
A: Yazılım geliştirmenin tüm yönleri ve boyutları ile ilgilenen disipline verilen isimdir.

**Q39**
:maple_leaf: Incremantal Yazılım Geliştirme nedir?
A: Tamamlanmamış versiyonlar arasında refactoring vb yöntemler ile yazılım extarnal (dış) davranışını değiştirmeden iç yapısında (internal) geliştirme yapılır.

**Q40**
:maple_leaf: Yazılım uygulama çeşitleri nelerdir? Örnekler ile açıklayınız.
A: Stand-alone applications:These are application systems that run on a local computer, such as a PC. They include all necessary functionality and do not need to be connected to a network.\
Interactive transaction-based applications: Applications that execute on a remote computer and are accessed by users from their own PCs or terminals. These include web applications such as e-commerce applications.\
Embedded control systems: These are software control systems that control and manage hardware devices. Numerically, there are probably more embedded systems than any other type of system.\
Batch processing systems: These are business systems that are designed to process data in large batches. They process large numbers of individual inputs to create corresponding outputs.\
Data collection systems: These are systems that collect data from their environment using a set of sensors and send that data to other systems for processing.


**Q41**
:maple_leaf:

**Q42**
:maple_leaf:

**Q43**
:maple_leaf:

**Q44**
:maple_leaf:

**Q45**
:maple_leaf:

</details>
  
<a href="#top">Back to top</a>

## :dvd: 08 Veritabanı ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :factory: 09 Bilgisayar Mimarisi ##

    .
    ├── BUS yapıları
    ├── Cache bellek
    ├── Komut kümeleri
    ├── Adresleme modları ve formatları
    ├── Register organizasyonu ve pipelining
    ├── RISC ve CISC mimarileri
    ├── Komut seviyesinde paralellik ve süperskalar işlemciler
    ├── Kontrol birimi
    ├── Multicore işlemciler
    ├── Çok işlemcili sistemler
    └── GPGPU


```sh
  .
  ├─ "Introduction to Computer Architecture and Organization"
  ├──   Define the Von Neumann architecture and explain its main components.
  ├──   Describe the difference between a computer's hardware and software.
  ├──   What is the function of the control unit in a computer?
  ├─ "Computer Performance and Measurement"
  ├──   Explain how Moore's Law relates to the advancement of computer technology.
  ├──   Describe the difference between instruction execution time and clock time.
  ├──   What is the difference between throughput and latency in computer performance?
  ├─ "Instruction Set Architecture"
  ├──   What is an instruction set architecture (ISA)?
  ├──   Explain the difference between CISC and RISC architectures.
  ├──   Describe the process of instruction decoding.
  ├─ "Computer Arithmetic and ALU Design"
  ├──   Explain the concept of fixed-point and floating-point representation of numbers in computer architecture.
  ├──   Describe the different types of arithmetic and logic operations that can be performed by an ALU.
  ├──   What is the significance of overflow and underflow in computer arithmetic?
  ├─ "Memory Hierarchy and Caching"
  ├──   Explain the concept of a memory hierarchy and the purpose of each level.
  ├──   Describe the difference between direct-mapped and fully-associative cache.
  ├──   What is a cache miss and how does it affect computer performance?
  ├─ "Processor Design and Microarchitecture"
  ├──   Explain the concept of pipelining in computer processors.
  ├──   Describe the difference between a scalar and a superscalar processor.
  ├──   What is the purpose of a branch predictor in a processor?
  ├─ "Parallelism and Multiprocessing"
  ├──   Explain the concept of parallelism in computer architecture.
  ├──   Describe the different types of parallelism (e.g. data parallelism, task parallelism).
  ├──   What is the difference between symmetric multiprocessing (SMP) and asymmetric multiprocessing (AMP)?
  ├─ "Storage Systems and I/O"
  ├──   Explain the concept of storage hierarchy and the purpose of each level.
  ├──   Describe the difference between magnetic and solid-state storage.
  ├──   What is the purpose of I/O devices in a computer system?
  ├─ "Advanced Topics in Computer Architecture"
  ├──   Explain the concept of virtual memory and how it works.
  ├──   Describe the difference between a normal memory access and a memory-mapped I/O access.
  ├──   What is the purpose of a GPU in a computer system?
  ├─ "Computer Architecture Exam Review and Best Practices"
  ├──   Explain the best practices for studying and preparing for an exam in computer architecture.
  ├──   Describe the importance of understanding the concepts and principles of computer architecture.
  └──   What are the most common mistakes made during an exam in computer architecture and how to avoid them?
```

<details> 
<summary> Çıkmış Sorular </summary>
  
**Q1**
:ferris_wheel: Does pipelining improve the latency of individual instructions? Explain.
ANS: Pipelining does NOT improve the latency of individual instructions. However, it improves the throughput. 

**Q2**
:ferris_wheel: What causes control hazards in a pipelined datapath and how control hazards can be eliminated?
ANS: Control hazards are caused by jump and branch instructions that are delayed in a pipelined datapath. They can be eliminated by converting the next (one or two) instructions that appear after a jump or a taken branch into NOPs.
 
**Q3**
:ferris_wheel: Explain the difference between static RAM and dynamic RAM
ANS: Static RAM: Cell is made out of 6 transistors and does not require refreshing.

Dynamic RAM: Cell is made out of 1 transistor and 1 capacitor, requires refreshing, but denser (cheaper) than SRAM.

**Q4**
:ferris_wheel: Is it possible to use only one memory for both instructions and data in the single-cycle datapath? Explain why or why not. Is it possible to use only one memory for both instructions and data in a multi-cycle datapath? Explain.
ANS: In a single-cycle datapath, a load instruction must be fetched and must read data during the same cycle. Using only one memory is NOT possible to fetch the instruction and load the data during the same cycle.  In a multi-cycle datapath, using only one memory IS possible because fetching the instruction and loading the data can occur in two different cycles.

**Q5**
:ferris_wheel: Why do we need cache memory, and why do we have two separate cache memories (I-cache and D-cache) in a pipelined processor? 
ANS: We need cache memory to reduce memory latency. Two separate caches (I-cache and D-cache) are needed to access both of them during the same cycle by two different instructions.

**Q6**
:ferris_wheel: Explain the concepts of temporal locality and spatial locality of reference in cache memory.
ANS: Temporal Locality: if a program references an instruction (or data) at a given address then it might reference the same address again in the future.\
Spatial Locality: if a program references an instruction (or data) at a given address then it might reference the next address in the memory. 

**Q7**
:ferris_wheel: What needs to be stored inside a cache for block identification? How does a cache know whether there is a cache hit or miss? 
ANS: A cache stores tags for block identification.\
The tag stored in the cache is compared against the tag in the memory address to determine whether there is a cache hit or miss.

**Q8**
:ferris_wheel: Suppose a 4-way set-associative cache has a capacity of 32 KiB (1 KiB = 1024 bytes) and each block consists of 64 Bytes. What is the total number of blocks in the cache? What is the number of sets?
ANS: Total number of blocks = 32 x 1024 / 64 = 512 blocks\
Number of sets = 512 / 4 = 128 sets 

**Q9**
:ferris_wheel: Explain the difference between a write-through and a write-back cache.
ANS: Write-through cache: every write to the cache is written to the lower-level
memory.\
Write-back cache: the write is done in the cache only. A modified bit is needed to indicate whether a block has been modified. Modified blocks are written back to
memory when replaced.

**Q10**
:ferris_wheel:
  
![SC_processor](https://user-images.githubusercontent.com/54834769/212698477-b0da6e53-5415-45ad-8732-23dedd00192a.JPG)

ANS:
  
![SC_processor_sol](https://user-images.githubusercontent.com/54834769/212698533-c5d4d59d-9a2e-4561-8a32-ac8a13222087.JPG)


**Q11**
:ferris_wheel:
  
![Performans_processor](https://user-images.githubusercontent.com/54834769/212698812-16dad7e3-2825-4696-bff3-768c03a2898b.JPG)


**Q12**
:ferris_wheel:
  
![pipeline1](https://user-images.githubusercontent.com/54834769/212698969-13aceb5a-2f3b-45c1-91d4-d047a3518ed2.JPG)

**Q13**
:ferris_wheel:
  
![pipeline2](https://user-images.githubusercontent.com/54834769/212699109-6ac2c380-8181-4777-a027-cd0778649cca.JPG) 


**Q14**
:ferris_wheel:
  
![cpu_design](https://user-images.githubusercontent.com/54834769/212699476-3d063d76-e6b2-40a6-9ce0-2e8d3bfef248.JPG)


**Q15**
:ferris_wheel:
  
![cpu_design2](https://user-images.githubusercontent.com/54834769/212699682-b315aef5-9584-444a-9ea1-10b895557029.JPG)


**Q16**
:ferris_wheel:
  
![cpu_design3](https://user-images.githubusercontent.com/54834769/212699904-b141d059-b512-4957-bff6-6ed0ee733481.JPG)

  
**Q17**
:ferris_wheel:
  
![cpu_design4](https://user-images.githubusercontent.com/54834769/212699943-3b65bb69-dddf-410f-8b07-1293c2b36c21.JPG)


**Q18**
:ferris_wheel:
  
![cache_memory](https://user-images.githubusercontent.com/54834769/212700231-e64bf31b-21e3-4dbc-b459-103c77c6c3a5.JPG)

**Q19**
:ferris_wheel:
  
![cache_perf](https://user-images.githubusercontent.com/54834769/212700266-99d4cfbd-32ac-4ec7-8613-8f47e6cf5f71.JPG)


  
**Q20**
:ferris_wheel: 
  
  ![Cache_organization](https://user-images.githubusercontent.com/54834769/213187048-db16767b-3b23-4408-bcbb-7d7338094b5f.JPG)

  
**Q21**
:ferris_wheel: Assume:
- A processor has a direct mapped cache
- Data words are 8 bits long (i.e. 1 byte)
- Data addresses are to the word
- A physical address is 20 bits long
- The tag is 11 bits
- Each block holds 16 bytes of data
How many blocks are in this cache?

  ANS:
  Given that the physical address is 20 bits long, and the tag is 11 bits, there are 9 bits left over for the index and offset
We can determine the number of bits of offset as the problem states that:
- Data is word addressable and words are 8 bits long
- Each block holds 16 bytes
As there are 8 bits / byte, each block holds 16 words, thus 4 bits of offset are needed.
This means that there are 5 bits left for the index. Thus, there are 2^5 or 32 blocks in the cache.

**Q22**
:ferris_wheel:
  
  ![Cache_organization#2](https://user-images.githubusercontent.com/54834769/213187342-d1d39996-822b-4b9b-9d00-b25db2e6dc9d.JPG)
  
  
**Q23**
:ferris_wheel: If a virtual-to-physical address translation takes ~100 clock cycles, what is the most likely reason for this particular latency? Your answer must fit in the box below.\
Solution:
- There was a TLB miss requiring a main memory access to read the page table
- The page table entry was valid and no page fault was incurred.

**Q24**
:ferris_wheel:
  
  ![amhdals_formula](https://user-images.githubusercontent.com/54834769/213188291-ef133315-7689-4e48-a3f3-f88944593321.JPG)

  
  **Q25**
:ferris_wheel: Bu soruda geçen terimlerin açıklamalarını yazınız.
  
  ![MSI_MESI_protokols](https://user-images.githubusercontent.com/54834769/213188786-53883708-c530-49a5-9d0a-c36f6834fb56.JPG)

  
  **Q26** 
:ferris_wheel: When would a compiler be able to use the lwu instruction to increase the speed of a program?

  ANS: When adjacent memory locations or array elements are accessed in a loop, we can perform both the memory access and address update to access the next element in one instruction. The original MIPS will require 2.
  
  
  **Q27**
:ferris_wheel: Why do RISC architectures use fixed-width instructions?

  ANS: To make instructions easy to decode and the implementation simpler. Variable-width instructions save memory, but require that the hardware handle instructions of varying width.
  
  
  **Q28**
:ferris_wheel: What are the steps required to add two floating point numbers?

ANS: 
1. Shift one number to make the exponents equal.
2. Perform the addition
3. Round the result
4. Normalize the result and adjust the exponent
  
  **Q29**
:ferris_wheel: What is the motivation for out-of-order execution in dynamic pipelining?
ANS: Out-of order execution allows the execution of instructions to start execution even though earlier instruction have stalled, which increases performance.
  
  
  **Q30**
:ferris_wheel: When does a page fault occur?
ANS:  When a processor with virtual memory attempts to access instructions or data that are not currently stored in the main memory but instead stored on disk.
  
  
  **Q31**
:ferris_wheel:
  
![block_design#1](https://user-images.githubusercontent.com/54834769/213191650-299ac156-95aa-4a66-b862-191770ad9254.JPG)
 
  *Üstteki sorunun başıdır.*
  
 ![block_design#2](https://user-images.githubusercontent.com/54834769/213191815-d6e4c063-9473-47d7-8c68-ffea943182e7.JPG)

![block_design#3](https://user-images.githubusercontent.com/54834769/213192014-3cc60e5d-934a-4f73-b237-afc207fabdd8.JPG)
 
  
  **Q32**
:ferris_wheel: What does Amdahl’s Law state? (In words, not a formula.)
ANS: The speedup is limited by the portion of the application you are accelerating
  
  
  **Q33**
:ferris_wheel: A program spends 75% of its time doing multiply instructions. If the multiplier is sped up by 3x,
how much faster does the application run? (Report your answer as “the program is X times faster.”)

  ANS: The program is 2x faster. (75% of the time is 3x faster, so that 75% now takes up 1/3 of that time, or only 25% of the original execution time. We have effectively eliminated 50% of the total execution time so the program is 2x faster.)
  
  
  **Q34**
:ferris_wheel: What is the limit on the maximum speedup if the multiplier in question 1b was infinitely fast? (Report your answer as “the program would be X times faster.”)

  ANS: The program would be 4x faster. (If the 75% of the time goes infinitely fast it will take 0 time, so the total program execution time will be reduced to 25% of what it originally was, or 4x faster.)
  
  
  **Q35**
:ferris_wheel: a) How do you do subtraction with two’s complement? (In words, not a formula.)
ANS: Using a regular adder, you invert the number to be subtracted and add one. (Set the carry in to true.)
  
  
  **Q36**
:ferris_wheel: For a 4-bit two’s complement number, show how to represent the following operations and their results. If you cannot, explain why. 
  
  b) 4-7
  
  ANS:
  4-7 = 4+-7 = 0100+1001 = 1101 = -3
 
  c) 11-3
  
  Cannot do this because 11 can not be represented in a 4-bit two’s complement number. The range is -8 to 7.
  
  **Q37**
:ferris_wheel:

  
  ![pipeline_depth](https://user-images.githubusercontent.com/54834769/213199466-65070fef-2280-45e2-bbb2-fe1ee79801d0.JPG)

  
  
  
  **Q38**
:ferris_wheel:
  
  
  ![CPI](https://user-images.githubusercontent.com/54834769/213200158-1139cf68-2f7c-4774-99ff-f727ac120c9b.JPG)
  
  
  **Q39**
:ferris_wheel:

  
  ![pipelining](https://user-images.githubusercontent.com/54834769/213200609-8b821b44-d06c-4ea2-9ae0-d4a9d68bf176.JPG)

  
  **Q40**
:ferris_wheel: The largest value that a 60-bit unsigned binary integer can represent is (260 -1). 
ANS: (True)
  
  
    **Q42**
:ferris_wheel: If a computer uses signed-2's complement representation and 8 bit registers, what range of integers can this computer represent?

  ANS: -128 to 127
  
  
    **Q43**
:ferris_wheel: “5 4 3 + × 2 × 6 –” is the reverse polish (postfix) notation of which of the following expressions
ANS: 5 × (4 + 3) × 2 – 6 
  
  
    **Q44**
:ferris_wheel: What is the overall speedup of a system that spends 65% of its time on I/O with a disk upgrade that provides for 50% greater throughput?
ANS: 28%
  
  
    **Q45**
:ferris_wheel: In the von Neumann model, explain the purpose of the processing unit and the program counter. 

  ANS: The processing unit performs all of the arithmetic and logic functions. The program counter is responsible for keeping track of the next instruction to fetch. 
  
  
    **Q46**
:ferris_wheel: 
  What are the maximum and minimum values that can be represented using 6 bits and
  
  i. 2’s complement representation and  
  
  ii. signed magnitude representations. 
  
ANS: i. Max: 31,  Min: -32
  
   ii. Max: 31, Min: 31
  
  
    **Q47**
:ferris_wheel:  Given the function: F(x,y,z)= xy'z + x'y'z + xyz, simplify the expression using Boolean algebra and identities and draw the logic diagram for the simplified expression.

  ANS: 
  
  ![expression#1](https://user-images.githubusercontent.com/54834769/213206329-9f0754be-c5af-4d5b-a55f-00cec544ab2a.JPG)

  
    **Q48**
:ferris_wheel: 
  
  ![expression#1](https://user-images.githubusercontent.com/54834769/213206755-17dcbaba-3780-4cc8-b052-10cfe087745e.JPG)

ANS: 
  
  ![expression#1_sol](https://user-images.githubusercontent.com/54834769/213206789-f043546f-0ded-4f10-b2cd-7e786573fabf.JPG)

 

    **Q49**
:ferris_wheel: 
  
   ![bit_questionJPG](https://user-images.githubusercontent.com/54834769/213206935-ba40b112-3721-497b-97a3-5e3b7aab0f3f.JPG)

  
  
    **Q50**
:ferris_wheel: 
  
  ![Multix_](https://user-images.githubusercontent.com/54834769/213207473-12c5b48e-aba3-4ebf-8c75-5f8184ca3883.JPG)
  
  
    **Q51**
:ferris_wheel:
  
  ![question](https://user-images.githubusercontent.com/54834769/213208308-f5052653-a96f-4565-be8e-67bf5a03cd92.JPG)

  
    **Q52**
:ferris_wheel: What is the difference between a decoder and a multiplexor? Explain with example and their block diagrams.
  
  
  ![decoder](https://user-images.githubusercontent.com/54834769/213208825-06d3e5fa-38f8-456a-8194-a391cbfe6935.JPG)


  A multiplexer is a device which allows one of a number of inputs to be routed to a single output. Here is a 4-1 multiplexer.
  
  ![mux](https://user-images.githubusercontent.com/54834769/213208879-307471b2-8c9a-4ff6-8bd2-7791d1583e08.JPG)

    
    **Q53**
:ferris_wheel: Name two RISC and two CISC processors. What are the main characteristics of RISC processors?
  
ANS: 
  
  
    **Q54**
:ferris_wheel:  Define (i) superscalar and (ii) super-pipeline concepts. Derive the equation for ideal speedup for a superscalar super-pipelined processor compared to a sequential processor. Assume N instructions, k-stage scalar base pipeline, superscalar degree of m, and superpipeline degree of n.
ANS: 
  
  
  
    **Q55**
  :ferris_wheel: 
  
a) What is the difference between computer architecture and computer organization?
  
b) What are the two locality principles observed with respect to user programs? How are these principles exploited in computer design?
  
c) What is virtual memory? Explain the need for virtual memory.
  
d) What are the main differences between a multi-processor system and a multi-computer system?
  
e) In a shared memory system, explain two schemes to maintain cache-coherence.
  
  
  **Q56**
  :ferris_wheel:
  
  ![CPI#2](https://user-images.githubusercontent.com/54834769/213210259-c66c093b-15a7-40f1-b28c-956751a55d62.JPG)

  
  **Q57**
  :ferris_wheel: 8. RISC CPU Design:
Design a (very) simple CPU for an instruction set that contains only the following four instructions: lw (load word), sw (store word), add, and jump (unconditional branch). Assume that the instruction formats are similar to the MIPS architecture. If you assume a different format, state the instruction formats. Show all the components, all the links, and all the control signals in the datapath. You must show only the minimal hardware required to implement these four instructions. For each instruction show the steps involved and the values of the control signals for a single cycle implementation. 
  
  
  
  
  **Q58**
  :ferris_wheel: 
  
  **Q59**
  :ferris_wheel: 
  
  
  **Q60**
  :ferris_wheel: 
  
  
  **Q61**
  :ferris_wheel: 
  
  
  
</details>

<a href="#top">Back to top</a>

## :sparkles: 10 Yapay Zeka ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>


## :memo: Lisans ##

This project is under license from MIT. For more details, see the [LICENSE](LICENSE) file.


Made with :heart: by <a href="https://github.com/otahsinb" target="_blank">otahsinb</a>

&#xa0;

<a href="#top">Back to top</a>
