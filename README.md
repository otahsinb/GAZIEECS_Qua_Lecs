# GU_CS_Qua_Lecs
Gazi University Computer Science Qualification Lecture Notes



# Software Engineering Lecture
Gazi University Computer Science Qualification Lecture Notes

**Q1:**
The stages of the software development lifecycle (SDLC):\
Ans: P-A-D-I-T-D-M\
:maple_leaf: Yazılım Geliştirme Yaşam Döngüsünün aşamaları:

Aşamalar  | Açıklamalar
------------- | -------------
1- Planlama:     | Defining the goals, scope, and constraints of the project.
2- Analiz:       | Gathering and documenting requirements for the software.
3- Tasarım:      | Creating a plan for the structure and functionality of the software.
4- Implementasyon:       | Writing and testing the code for the software.
5- Testing:     | Evaluating the software to ensure it meets the requirements and is of high quality.
6- Deployment:       | Making the software available for use in a production environment.
7- Maintenance:     | Ongoing support, bug fixes, and updates for the software.

**Q2:**
:maple_leaf: Yazılım Geliştirme'de accidental ve essential complexity arasındaki ilişkiyi açıklayınız:

Kavram  | Açıklamalar
------------- | -------------
1- Accidental complexity:               | Yazılım geliştirme sürecinde kullanılan araç ve teknolojilerin etkisi ile ortaya çıkan karmaşıklıktır. (Refers to the complexity that arises due to the limitations of the tools and techniques used to build the software. )
2- Essential complexity:                | Yazılım geliştirme sürecinde yazılım tarafından çözülen problemden kaynaklanan kalıtsal karmaşıklıktır. (Refers to the inherent complexity of the problem being solved by the software)
3- Relation between A&E complexity:     | **No silver bullet veya no single technique veya araç** yaklaşımı ile yazılım geliştirmedeki karmaşıklığı azaltabileceğimiz belirtilmektedir. Bu yaklaşımda 1- Yüksek seviye programalama dillerinin kullanılması ve daha güçlü bilgisayarların kullanılması daha etkili ve etkin yollar ile accidental karmaşıklığı azaltabilir. 2- Moduler tasarımlar ile yazılım daha küçük parçalara ayrılarak daha kolay yönetilebilir. 3- Daha sistematik yaklaşımlar ile örneğin test ve debug araçları kullanarak karmaşıklık azaltılabilir. Özetle yazılım geliştirme süreçlerindeki karmaşıklığı azaltmak ve üretkenliği artırmak için daha iyi araçlar, teknikler ve sistematik prensiplere yönelmek gerekmektedir. (**No silver bullet – no single technique or tool** that can significantly reduce the essential complexity of software development. However, he does identify some promising approaches for improving how we build software, including: 1- Using higher-level programming languages and more powerful computers, which can help reduce accidental complexity by providing more expressive and efficient ways of solving problems. 2- Using modular design and structured programming techniques to break down complex systems into smaller, more manageable pieces. 3- Adopting a rigorous and systematic approach to software development, including the use of testing and debugging tools and practices. Overall, the key to improving software development is to focus on reducing accidental complexity and increasing the productivity and effectiveness of developers. This can be achieved through the use of better tools and techniques, as well as through the adoption of sound engineering practices and principles.)

**Q3:**
:maple_leaf: Describe briefly what distinguishes the "agile" approaches to software development from more traditional approaches. Identify at least two of the reasons
behind the agile approaches described by Fowler in his "The New Methodology" article:

**Q4:**
:maple_leaf: Describe briefly what we mean by the terms coupling and cohesion:

**Q5:**
:maple_leaf: Describe briefly what we mean by the term software architecture. Give an example of at least one architectural style from our readings:

**Q6:**
:maple_leaf: Describe briefly what we mean by the term design pattern. Give two examples of design patterns from our readings:

**Q7:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q8:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q9:**
:maple_leaf: Choose three of these design principles. For each, either describe it briefly or give an example that illustrates it.

• Single Responsibility Principle: \
• Open-Closed Principle: \
• Liskov's Substitution Principle: \
• Dependency Inversion Principle: \
• Interface Segregation Principle:

**Q10:**
:maple_leaf: Draw a simple UML class diagram that shows the relationships among customers who place orders for various kinds of office supplies from a retail store. The store serves both individuals and corporate clients. Payments are made via cash, credit, and invoice.
