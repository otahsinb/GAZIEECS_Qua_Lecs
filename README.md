<div align="center" id="top"> 
  <img src="./ftry.jpg" alt="insallah" />

  &#xa0;

</div>

<h1 align="center">Doktora Yeterlik Sınavı Çalışma Alanı</h1>

<p align="center">
  <img alt="Github top language" src="https://img.shields.io/github/languages/top/otahsinb/GAZIEECS_Qua_Lecs">

  <img alt="Github stars" src="https://img.shields.io/github/stars/otahsinb/GAZIEECS_Qua_Lecs" />

  <img alt="License" src="https://img.shields.io/github/license/otahsinb/GAZIEECS_Qua_Lecs">

  <!-- <img alt="Github issues" src="https://img.shields.io/github/issues/otahsinb/GAZIEECS_Qua_Lecs" /> -->

  <!-- <img alt="Repository size" src="https://img.shields.io/github/repo-size/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github language count" src="https://img.shields.io/github/languages/count/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github forks" src="https://img.shields.io/github/forks/0otahsinb/GAZIEECS_Qua_Lecs" /> -->

</p>


<p align="center">
  <a href="#dart-00-açıklama">00 Açıklama</a> &#xa0; | &#xa0; 
  <a href="#sparkler-01-veri-yapıları">01 Veri Yapıları</a> &#xa0; | &#xa0;
  <a href="#octocat-02-algoritmalar">02 Algoritmalar</a> &#xa0; | &#xa0;
  <a href="#surfer-03-ayrık-matematik">03 Ayrık Matematik</a> &#xa0; | &#xa0;
  <a href="#dizzy-04-bilgisayar-ağları">04 Bilgisayar Ağları</a> &#xa0; | &#xa0;
  <a href="#art-05-işletim-sistemleri">05 Işletim Sistemleri</a> &#xa0; | &#xa0;
  <a href="#twisted_rightwards_arrows-06-sayısal-tasarım">06 Sayısal Tasarım</a> &#xa0; | &#xa0;
  <a href="#fish_cake-07-yazılım-mühendisliği">07 Yazılım Mühendisliği</a> &#xa0; | &#xa0;
  <a href="#dvd-08-veritabanı">08 Veritabanı</a> &#xa0; | &#xa0;
  <a href="#factory-09-bilgisayar-mimarisi">09 Bilgisayar Mimarisi</a> &#xa0; | &#xa0;
  <a href="#sparkles-10-yapay-zeka">10 Yapay Zeka</a> &#xa0; | &#xa0;
  <a href="#memo-lisans">Lisans</a> &#xa0; | &#xa0;
  <a href="https://github.com/otahsinb" target="_blank">Yazar</a>
</p>

<br>

## :dart: 00 Açıklama ##

 Bu alan bilgisayar bilimleri doktora yeterlik sınavı notlarını kaydetme amacıyla kendim için açtığım bir alandır. Burada yeterlik sınavında sorumlu olunan derslerin notlarını bulabilirsiniz.
 
 ```bash
# Clone this project
$ git clone https://github.com/otahsinb/GAZIEECS_Qua_Lecs

# Access
$ cd GAZIEECS_Qua_Lecs

# Run the project
$ python xxx.py
```

If you do not compile to\

You can build this with the following command:
> python setup.py build_ext --inplace
 
 First there's [here](https://pyob.oxyry.com/) but purchasing it c junk code and custom encryption, and includes the obfuscation found in Carbon.
:heavy_check_mark: Dersler ve Konu Başlıkları \
:heavy_check_mark: Linkler \
:heavy_check_mark: Kullanışlı Araçlar\
:heavy_check_mark: Sınavlar\
:heavy_check_mark: Notlar




## :sparkler: 01 Veri Yapıları ##

...

<a href="#top">Back to top</a>

## :octocat: 02 Algoritmalar ##
...

<a href="#top">Back to top</a>

## :surfer: 03 Ayrık Matematik ##

...

<a href="#top">Back to top</a>

## :dizzy: 04 Bilgisayar Ağları ##

...

<a href="#top">Back to top</a>

## :art: 05 Işletim Sistemleri ##

...

<a href="#top">Back to top</a>

## :twisted_rightwards_arrows: 06 Sayısal Tasarım ##

...

<a href="#top">Back to top</a>

## :fish_cake: 07 Yazılım Mühendisliği ##

**Q1:**
The stages of the software development lifecycle (SDLC):\
Ans: P-A-D-I-T-D-M\
:maple_leaf: Yazılım Geliştirme Yaşam Döngüsünün aşamaları:

Aşamalar  | Açıklamalar
------------- | -------------
1- Planlama:     | Defining the goals, scope, and constraints of the project.
2- Analiz:       | Gathering and documenting requirements for the software.
3- Tasarım:      | Creating a plan for the structure and functionality of the software.
4- Implementasyon:       | Writing and testing the code for the software.
5- Testing:     | Evaluating the software to ensure it meets the requirements and is of high quality.
6- Deployment:       | Making the software available for use in a production environment.
7- Maintenance:     | Ongoing support, bug fixes, and updates for the software.

**Q2:**
:maple_leaf: Yazılım Geliştirme'de accidental ve essential complexity arasındaki ilişkiyi açıklayınız:

Kavram  | Açıklamalar
------------- | -------------
1- Accidental complexity:               | Yazılım geliştirme sürecinde kullanılan araç ve teknolojilerin etkisi ile ortaya çıkan karmaşıklıktır. (Refers to the complexity that arises due to the limitations of the tools and techniques used to build the software. )
2- Essential complexity:                | Yazılım geliştirme sürecinde yazılım tarafından çözülen problemden kaynaklanan kalıtsal karmaşıklıktır. (Refers to the inherent complexity of the problem being solved by the software)
3- Relation between A&E complexity:     | **No silver bullet veya no single technique veya araç** yaklaşımı ile yazılım geliştirmedeki karmaşıklığı azaltabileceğimiz belirtilmektedir. Bu yaklaşımda 1- Yüksek seviye programalama dillerinin kullanılması ve daha güçlü bilgisayarların kullanılması daha etkili ve etkin yollar ile accidental karmaşıklığı azaltabilir. 2- Moduler tasarımlar ile yazılım daha küçük parçalara ayrılarak daha kolay yönetilebilir. 3- Daha sistematik yaklaşımlar ile örneğin test ve debug araçları kullanarak karmaşıklık azaltılabilir. Özetle yazılım geliştirme süreçlerindeki karmaşıklığı azaltmak ve üretkenliği artırmak için daha iyi araçlar, teknikler ve sistematik prensiplere yönelmek gerekmektedir. (**No silver bullet – no single technique or tool** that can significantly reduce the essential complexity of software development. However, he does identify some promising approaches for improving how we build software, including: 1- Using higher-level programming languages and more powerful computers, which can help reduce accidental complexity by providing more expressive and efficient ways of solving problems. 2- Using modular design and structured programming techniques to break down complex systems into smaller, more manageable pieces. 3- Adopting a rigorous and systematic approach to software development, including the use of testing and debugging tools and practices. Overall, the key to improving software development is to focus on reducing accidental complexity and increasing the productivity and effectiveness of developers. This can be achieved through the use of better tools and techniques, as well as through the adoption of sound engineering practices and principles.)

**Q3:**
:maple_leaf: Describe briefly what distinguishes the "agile" approaches to software development from more traditional approaches. Identify at least two of the reasons
behind the agile approaches described by Fowler in his "The New Methodology" article:

**Q4:**
:maple_leaf: Describe briefly what we mean by the terms coupling and cohesion:

**Q5:**
:maple_leaf: Describe briefly what we mean by the term software architecture. Give an example of at least one architectural style from our readings:

**Q6:**
:maple_leaf: Describe briefly what we mean by the term design pattern. Give two examples of design patterns from our readings:

**Q7:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q8:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q9:**
:maple_leaf: Choose three of these design principles. For each, either describe it briefly or give an example that illustrates it.

• Single Responsibility Principle: \
• Open-Closed Principle: \
• Liskov's Substitution Principle: \
• Dependency Inversion Principle: \
• Interface Segregation Principle:

**Q10:**
:maple_leaf: Draw a simple UML class diagram that shows the relationships among customers who place orders for various kinds of office supplies from a retail store. The store serves both individuals and corporate clients. Payments are made via cash, credit, and invoice.


**Q11**
:maple_leaf: Name and define (in the context of software engineering) one desirable software quality, other than “maintainability” and “correctness,”

**Q12**
:maple_leaf: software process model nedir? Örnekler ile açıklayınız.

**Q13**
:maple_leaf: explain processes of requirements engineering.

**Q14**
:maple_leaf: explain Extreme Programming practices.

**Q15** 
:maple_leaf: Why is the waterfall model called an “ideal” model?
Short Answer: It represents the software process as having no imperfections.

**Q16**
:maple_leaf: Draw a UML class diagram (chapter 5, slide 9) representing a book defined by the following statement: “A book is composed of a number of parts, which in turn are composed of a number of chapters. Chapters are composed of sections.” Focus only on classes and relationships.  Add multiplicity to the class diagram you produced.

**Q17**
:maple_leaf: List and describe (using at least one sentence each) the three types of software maintenance.  Which one of the three typically gets over half (65%) of the maintenance effort?  (in other words, more time is spent on this type of maintenance). Why?

**Q18**
:maple_leaf: List and describe at least three techniques for deriving test cases (for any kind of software testing).  Your answer should have at least three sentences (at least one for each technique).

**Q19**
:maple_leaf: Draw a class diagram showing the structure of data about employees of a given company.  The employees attributes include name, street address, city, state, zip, and an id number.  The employees also have an annual salary.  Departments have names and are composed of a collection of employees, but each employee can be in only one department.  Employees work on one or more projects, which also have names.  Projects may have multiple employees assigned to them. Include multiplicity, and attributes in your diagram. 

**Q20**
:maple_leaf: Given the UML class diagram on the next page decompose it into a set of components (subsystems) that has at least 2 (but no more than 4) components. Use the goals of loose coupling and high cohesion (and any other heuristics that may apply) for deciding which classes should go in each component.


<img src="./or1.PNG" alt="or1" />

**Q21**
:maple_leaf: Draw a control flow diagram for the following source code:  Then:
•assign a number to each node.
•list the unique paths through the control flow diagram (use a sequence of node numbers to identify each path).
•for each unique path, generate a test case by giving values to use for a, b, and c to make the program run through that path. Also give the expected result (the value of d). 

> d = 0;
> 
> if (a > b);
> 
>> d = d+1;
>> 
> if (b > c);
> 
>> d = d+2;
>> 
> cout << d << endl;


**Q22**
:maple_leaf: Test a method called “verifyPassword” that takes a string representing a proposed password, and returns true if it meets the following criteria (and false if it doesn’t):
•at least 7 characters •at least one digit
•at least one uppercase letter Identify at least 5 testing partitions for this function, and derive a set of test cases (one for each partition).  Be sure to include the test data value(s) and expected result(s) for each test case.

**Q23**
:maple_leaf: Develop a set of use case diagrams (with one-sentence textual descriptions) to describe the requirements for a university scheduling system that manages the university’s course offerings, including students registering for courses. You should include at least 3 actors. Each actor should have at least one use case that is unique. You should have at least 5 use cases (interactions).

**Q24**
:maple_leaf: Design and draw the basic architecture of a video chess game that can be played on a smart phone using one of the architectural design patterns from chapter 6 (indicate in your answer which pattern you are using). The current state of the game board should be able to be viewed in 2D or 3D or even in a text format (suitable for e-mailing). The user can move pieces by touching and dragging the pieces on the screen. The moves may be animated (or not).


**Q25**
:maple_leaf: List and describe three methods or tools used during requirements development (in any of the four sub-disciplines). How does each method contribute to the goal of developing requirements specifications of good quality?


**Q26**
:maple_leaf: Choose 3 of the 12 core practices of Extreme Programming (XP) and give a brief description of each. For each one indicate what benefit it provides over more traditional development methods (assuming it is used in the context of agile development).


**Q27**
:maple_leaf: Give an example of a design pattern whose use is obvious from a class diagram but not from a sequence diagram. (Don’t choose one that is built into (some) programming languages, such as inheritance.) Explain why, in 1 sentence.

Short Ans: Composite: the members of a class are of a type that allows similar operations (perhaps they implement an interface in common with the container class). Observer: especially easy if there’s an hobservesi notation on an arrow. For many patterns it’s possible to argue either way (and we were looking for your argument, not just a name). A common pitfall here was conflating class and object diagrams.


**Q28**
:maple_leaf: Give an example of a design pattern whose use is obvious from a sequence diagram but not from a class diagram. (Don’t choose one that is built into (some) programming languages, such as iteration.) Explain why, in 1 sentence.

Short Ans : Factory: an actor creates an object in response to a call, and the caller subsequently sends messages to the newly created object. Decorator: every message to the decorator object is followed by a call to the object it decorates.


**Q29**
:maple_leaf: Consider two components A and B. Two software engineers, Laurel and Hardy, measure the dependences between A and B. Laurel uses these dependences when computing cohesion, and Hardy uses these dependences when computing coupling. Is this possible, if both engineers are performing a sensible and useful computation? In 1–2 sentences, explain why or why not.

SA: Yes. Laurel is considering a larger module C that contains both A and B as implementation details. Hardy is considering the implementation of C, and thinking of A and B as modules. 

**Q30**
:maple_leaf:


**Q31**
:maple_leaf:


**Q32**
:maple_leaf:


**Q33**
:maple_leaf:




<a href="#top">Back to top</a>

## :dvd: 08 Veritabanı ##

...

<a href="#top">Back to top</a>

## :factory: 09 Bilgisayar Mimarisi ##

...

<a href="#top">Back to top</a>

## :sparkles: 10 Yapay Zeka ##

...

<a href="#top">Back to top</a>


## :memo: Lisans ##

This project is under license from MIT. For more details, see the [LICENSE](LICENSE) file.


Made with :heart: by <a href="https://github.com/otahsinb" target="_blank">otahsinb</a>

&#xa0;

<a href="#top">Back to top</a>
