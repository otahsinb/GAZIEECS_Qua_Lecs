<div align="center" id="top"> 
  <img src="./ftry.jpg" alt="insallah" />

  &#xa0;

</div>

<h1 align="center">Doktora Yeterlik Sınavı Çalışma Alanı</h1>

<p align="center">
  <img alt="Github top language" src="https://img.shields.io/github/languages/top/otahsinb/GAZIEECS_Qua_Lecs">

  <img alt="Github stars" src="https://img.shields.io/github/stars/otahsinb/GAZIEECS_Qua_Lecs" />

  <img alt="License" src="https://img.shields.io/github/license/otahsinb/GAZIEECS_Qua_Lecs">

  <!-- <img alt="Github issues" src="https://img.shields.io/github/issues/otahsinb/GAZIEECS_Qua_Lecs" /> -->

  <!-- <img alt="Repository size" src="https://img.shields.io/github/repo-size/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github language count" src="https://img.shields.io/github/languages/count/otahsinb/GAZIEECS_Qua_Lecs"> -->
  
  <!-- <img alt="Github forks" src="https://img.shields.io/github/forks/0otahsinb/GAZIEECS_Qua_Lecs" /> -->

</p>


<p align="center">
  <a href="#dart-00-açıklama">00 Açıklama</a> &#xa0; | &#xa0; 
  <a href="#sparkler-01-veri-yapıları">01 Veri Yapıları</a> &#xa0; | &#xa0;
  <a href="#octocat-02-algoritmalar">02 Algoritmalar</a> &#xa0; | &#xa0;
  <a href="#surfer-03-ayrık-matematik">03 Ayrık Matematik</a> &#xa0; | &#xa0;
  <a href="#dizzy-04-bilgisayar-ağları">04 Bilgisayar Ağları</a> &#xa0; | &#xa0;
  <a href="#art-05-işletim-sistemleri">05 Işletim Sistemleri</a> &#xa0; | &#xa0;
  <a href="#twisted_rightwards_arrows-06-sayısal-tasarım">06 Sayısal Tasarım</a> &#xa0; | &#xa0;
  <a href="#fish_cake-07-yazılım-mühendisliği">07 Yazılım Mühendisliği</a> &#xa0; | &#xa0;
  <a href="#dvd-08-veritabanı">08 Veritabanı</a> &#xa0; | &#xa0;
  <a href="#factory-09-bilgisayar-mimarisi">09 Bilgisayar Mimarisi</a> &#xa0; | &#xa0;
  <a href="#sparkles-10-yapay-zeka">10 Yapay Zeka</a> &#xa0; | &#xa0;
  <a href="#memo-lisans">Lisans</a> &#xa0; | &#xa0;
  <a href="https://github.com/otahsinb" target="_blank">Yazar</a>
</p>

<br>

## :dart: 00 Açıklama ##

 Bu alan bilgisayar bilimleri doktora yeterlik sınavı notlarını kaydetme amacıyla kendim için açtığım bir alandır. Burada yeterlik sınavında sorumlu olunan derslerin notlarını bulabilirsiniz.
 
 ```bash
# Clone this project
$ git clone https://github.com/otahsinb/GAZIEECS_Qua_Lecs

# Access
$ cd GAZIEECS_Qua_Lecs

# Run the project
$ python xxx.py
```

If you do not compile to\

You can build this with the following command:
> python setup.py build_ext --inplace
 
 First there's [here](https://pyob.oxyry.com/) but purchasing it c junk code and custom encryption, and includes the obfuscation found in Carbon.
:heavy_check_mark: Dersler ve Konu Başlıkları \
:heavy_check_mark: Linkler \
:heavy_check_mark: Kullanışlı Araçlar\
:heavy_check_mark: Sınavlar\
:heavy_check_mark: Notlar




## :sparkler: 01 Veri Yapıları ##

<details>
<summary> Konu Başlıkları </summary>
  
  ```sh
    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 
  ```
  
</details>

<a href="#top">Back to top</a>

## :octocat: 02 Algoritmalar ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :surfer: 03 Ayrık Matematik ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :dizzy: 04 Bilgisayar Ağları ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :art: 05 Işletim Sistemleri ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :twisted_rightwards_arrows: 06 Sayısal Tasarım ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :fish_cake: 07 Yazılım Mühendisliği ##

    .
    ├── Software Engineering Methods
    ├── Software Development Processes
    ├── System modeling, context models, Interaction models, Structural models
    ├── Software Requirements
    ├── Software Modelling
    ├── Behavioral models, model-driven engineering
    ├── Prototyping
    ├── Software Design and Representation
    ├── User Interface Design
    ├── Software Testing
    ├── Software Project Management
    ├── Software Quality Assurance
    └── Software Process Improvement


**Q1:**
The stages of the software development lifecycle (SDLC):\
Ans: P-A-D-I-T-D-M\
:maple_leaf: Yazılım Geliştirme Yaşam Döngüsünün aşamaları:

Aşamalar  | Açıklamalar
------------- | -------------
1- Planlama:     | Defining the goals, scope, and constraints of the project.
2- Analiz:       | Gathering and documenting requirements for the software.
3- Tasarım:      | Creating a plan for the structure and functionality of the software.
4- Implementasyon:       | Writing and testing the code for the software.
5- Testing:     | Evaluating the software to ensure it meets the requirements and is of high quality.
6- Deployment:       | Making the software available for use in a production environment.
7- Maintenance:     | Ongoing support, bug fixes, and updates for the software.

**Q2:**
:maple_leaf: Yazılım Geliştirme'de accidental ve essential complexity arasındaki ilişkiyi açıklayınız:

Kavram  | Açıklamalar
------------- | -------------
1- Accidental complexity:               | Yazılım geliştirme sürecinde kullanılan araç ve teknolojilerin etkisi ile ortaya çıkan karmaşıklıktır. (Refers to the complexity that arises due to the limitations of the tools and techniques used to build the software. )
2- Essential complexity:                | Yazılım geliştirme sürecinde yazılım tarafından çözülen problemden kaynaklanan kalıtsal karmaşıklıktır. (Refers to the inherent complexity of the problem being solved by the software)
3- Relation between A&E complexity:     | **No silver bullet veya no single technique veya araç** yaklaşımı ile yazılım geliştirmedeki karmaşıklığı azaltabileceğimiz belirtilmektedir. Bu yaklaşımda 1- Yüksek seviye programalama dillerinin kullanılması ve daha güçlü bilgisayarların kullanılması daha etkili ve etkin yollar ile accidental karmaşıklığı azaltabilir. 2- Moduler tasarımlar ile yazılım daha küçük parçalara ayrılarak daha kolay yönetilebilir. 3- Daha sistematik yaklaşımlar ile örneğin test ve debug araçları kullanarak karmaşıklık azaltılabilir. Özetle yazılım geliştirme süreçlerindeki karmaşıklığı azaltmak ve üretkenliği artırmak için daha iyi araçlar, teknikler ve sistematik prensiplere yönelmek gerekmektedir. (**No silver bullet – no single technique or tool** that can significantly reduce the essential complexity of software development. However, he does identify some promising approaches for improving how we build software, including: 1- Using higher-level programming languages and more powerful computers, which can help reduce accidental complexity by providing more expressive and efficient ways of solving problems. 2- Using modular design and structured programming techniques to break down complex systems into smaller, more manageable pieces. 3- Adopting a rigorous and systematic approach to software development, including the use of testing and debugging tools and practices. Overall, the key to improving software development is to focus on reducing accidental complexity and increasing the productivity and effectiveness of developers. This can be achieved through the use of better tools and techniques, as well as through the adoption of sound engineering practices and principles.)

**Q3:**
:maple_leaf: Describe briefly what distinguishes the "agile" approaches to software development from more traditional approaches. Identify at least two of the reasons
behind the agile approaches described by Fowler in his "The New Methodology" article:

**Q4:**
:maple_leaf: Describe briefly what we mean by the terms coupling and cohesion:

**Q5:**
:maple_leaf: Describe briefly what we mean by the term software architecture. Give an example of at least one architectural style from our readings:

**Q6:**
:maple_leaf: Describe briefly what we mean by the term design pattern. Give two examples of design patterns from our readings:

**Q7:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q8:**
:maple_leaf: Give an example of how Model-View-Controller could be used to implement a system you are familiar with:

**Q9:**
:maple_leaf: Choose three of these design principles. For each, either describe it briefly or give an example that illustrates it.

• Single Responsibility Principle: \
• Open-Closed Principle: \
• Liskov's Substitution Principle: \
• Dependency Inversion Principle: \
• Interface Segregation Principle:

**Q10:**
:maple_leaf: Draw a simple UML class diagram that shows the relationships among customers who place orders for various kinds of office supplies from a retail store. The store serves both individuals and corporate clients. Payments are made via cash, credit, and invoice.


**Q11**
:maple_leaf: Name and define (in the context of software engineering) one desirable software quality, other than “maintainability” and “correctness,”

**Q12**
:maple_leaf: software process model nedir? Örnekler ile açıklayınız.

**Q13**
:maple_leaf: explain processes of requirements engineering.

**Q14**
:maple_leaf: explain Extreme Programming practices.

**Q15** 
:maple_leaf: Why is the waterfall model called an “ideal” model?
Short Answer: It represents the software process as having no imperfections.

**Q16**
:maple_leaf: Draw a UML class diagram (chapter 5, slide 9) representing a book defined by the following statement: “A book is composed of a number of parts, which in turn are composed of a number of chapters. Chapters are composed of sections.” Focus only on classes and relationships.  Add multiplicity to the class diagram you produced.

**Q17**
:maple_leaf: List and describe (using at least one sentence each) the three types of software maintenance.  Which one of the three typically gets over half (65%) of the maintenance effort?  (in other words, more time is spent on this type of maintenance). Why?

**Q18**
:maple_leaf: List and describe at least three techniques for deriving test cases (for any kind of software testing).  Your answer should have at least three sentences (at least one for each technique).

**Q19**
:maple_leaf: Draw a class diagram showing the structure of data about employees of a given company.  The employees attributes include name, street address, city, state, zip, and an id number.  The employees also have an annual salary.  Departments have names and are composed of a collection of employees, but each employee can be in only one department.  Employees work on one or more projects, which also have names.  Projects may have multiple employees assigned to them. Include multiplicity, and attributes in your diagram. 

**Q20**
:maple_leaf: Given the UML class diagram on the next page decompose it into a set of components (subsystems) that has at least 2 (but no more than 4) components. Use the goals of loose coupling and high cohesion (and any other heuristics that may apply) for deciding which classes should go in each component.


<img src="./or1.PNG" alt="or1" />

**Q21**
:maple_leaf: Draw a control flow diagram for the following source code:  Then:
•assign a number to each node.
•list the unique paths through the control flow diagram (use a sequence of node numbers to identify each path).
•for each unique path, generate a test case by giving values to use for a, b, and c to make the program run through that path. Also give the expected result (the value of d). 

> d = 0;
> 
> if (a > b);
> 
>> d = d+1;
>> 
> if (b > c);
> 
>> d = d+2;
>> 
> cout << d << endl;


**Q22**
:maple_leaf: Test a method called “verifyPassword” that takes a string representing a proposed password, and returns true if it meets the following criteria (and false if it doesn’t):
•at least 7 characters •at least one digit
•at least one uppercase letter Identify at least 5 testing partitions for this function, and derive a set of test cases (one for each partition).  Be sure to include the test data value(s) and expected result(s) for each test case.

**Q23**
:maple_leaf: Develop a set of use case diagrams (with one-sentence textual descriptions) to describe the requirements for a university scheduling system that manages the university’s course offerings, including students registering for courses. You should include at least 3 actors. Each actor should have at least one use case that is unique. You should have at least 5 use cases (interactions).

**Q24**
:maple_leaf: Design and draw the basic architecture of a video chess game that can be played on a smart phone using one of the architectural design patterns from chapter 6 (indicate in your answer which pattern you are using). The current state of the game board should be able to be viewed in 2D or 3D or even in a text format (suitable for e-mailing). The user can move pieces by touching and dragging the pieces on the screen. The moves may be animated (or not).


**Q25**
:maple_leaf: List and describe three methods or tools used during requirements development (in any of the four sub-disciplines). How does each method contribute to the goal of developing requirements specifications of good quality?


**Q26**
:maple_leaf: Choose 3 of the 12 core practices of Extreme Programming (XP) and give a brief description of each. For each one indicate what benefit it provides over more traditional development methods (assuming it is used in the context of agile development).


**Q27**
:maple_leaf: Give an example of a design pattern whose use is obvious from a class diagram but not from a sequence diagram. (Don’t choose one that is built into (some) programming languages, such as inheritance.) Explain why, in 1 sentence.

Short Ans: Composite: the members of a class are of a type that allows similar operations (perhaps they implement an interface in common with the container class). Observer: especially easy if there’s an hobservesi notation on an arrow. For many patterns it’s possible to argue either way (and we were looking for your argument, not just a name). A common pitfall here was conflating class and object diagrams.


**Q28**
:maple_leaf: Give an example of a design pattern whose use is obvious from a sequence diagram but not from a class diagram. (Don’t choose one that is built into (some) programming languages, such as iteration.) Explain why, in 1 sentence.

Short Ans : Factory: an actor creates an object in response to a call, and the caller subsequently sends messages to the newly created object. Decorator: every message to the decorator object is followed by a call to the object it decorates.


**Q29**
:maple_leaf: Consider two components A and B. Two software engineers, Laurel and Hardy, measure the dependences between A and B. Laurel uses these dependences when computing cohesion, and Hardy uses these dependences when computing coupling. Is this possible, if both engineers are performing a sensible and useful computation? In 1–2 sentences, explain why or why not.

SA: Yes. Laurel is considering a larger module C that contains both A and B as implementation details. Hardy is considering the implementation of C, and thinking of A and B as modules. 

**Q30**
:maple_leaf: Consider two components A and B. Two software engineers, Laurel and Hardy, measure the dependences between A and B. Laurel uses these dependences when computing cohesion, and Hardy uses these dependences when computing coupling. Is this possible, if both engineers are performing a sensible and useful computation? In 1–2 sentences, explain why or why not.
SA: Yes. Laurel is considering a larger module C that contains both A and B as implementation details. Hardy is considering the implementation of C, and thinking of A and B as modules.

**Q31**
:maple_leaf: In 1 sentence each, give two distinct reasons that you should not commit compiled code (such as .o or .class files) to a version control repository

SAs: Merge conflicts cannot be resolved. Another way of saying the same thing is that binary files are not diffable (by the standard text-based diff algorithms).\
Repetition of information in source and binary forms violates the DRY (don’t repeat yourself)
principle.\
Binary files such as .o files are architecture-dependent and may not be useful to others.\
Binary files may contain information such as timestamps that is guaranteed to create a conflict even if generated from the same source code by others.\
Bloat in the VCS because differences are huge.\
Timestamps might not be preserved.\
If there is a check-in without compiling, then they can be inconsistent with the source code.

**Q32**
:maple_leaf:  It is cheaper and faster to fix known bugs before you write new code. Why? In one phrase or sentence each, give three reasons. Give reasons that are as different from one another as possible.

SAs:\
• You are familiar with the code now. A related reason is that the bug will be harder to find and fix later.\
• Later code may depend on this code. A related reason is that a bug may reveal a fundamental problem.\
• Leaving all bugs to the end will make it harder to understand and keep to the schedule, because it’s hard to predict how long bug fixing will take.\
• An overfull bug database is demoralizing and is likely to be ignored.\
• You will be able to add tests for the bug once it’s been fixed to avoid future issues.\
• Avoid feature creep.


**Q33**
:maple_leaf: After you find a bug but before fixing it, you should create a test case for it. In one sentence each, give three reasons that this is a good idea. Give reasons that are as distinct as possible.

SAs:\

• Ensures that your fix solves the problem. Don’t add a test that succeeded to begin with! A related reason is to avoid writing a test for a bug that you fixed, but that isn’t the problem indicated by the original bug fix.\
• It helps you understand the bug and define the desired system behavior. (“It documents the bug” or “it informs others of the bug” is wrong, because it is the purpose of your bug tracking system to document your bugs. If you meant something different, such as the good answers listed here, then please be more specific.)\
• It helps you know when you are done with bug fixing. A related reason is repeatability, and efficiency when debugging: the test is easy to run in an automated way to determine whether your fix works.

Here are some more answers we accepted, even though they are really just reasons to write a test at all, and not reasons to write the test before you fix the bug:\
• Helps to populate test suite with good tests. The test case may reveal other problems also, that would make sense to fix at the same time.\
• Protects against reversions that reintroduce bug. It happened at least once, and it might happen again.


**Q34**
:maple_leaf: Consider a wrapper whose implementation logs each call that occurs. In no more than 2 sentences each, explain when the wrapper should be considered a decorator (and why), and when that same wrapper should be considered a proxy (and why).\

SAs:\

• Decorator: A decorator has different functionality but the same interface as the delegate. If the wrapper’s specification requires it to do the logging, then it should be considered a decorator.\
• Proxy: A proxy has the same functionality and the same interface as the delegate. If the wrapper has a lenient specification that permits but does not require it to perform logging, then it should be considered a proxy.\


**Q35**
:maple_leaf: ) Recall that the interning pattern guarantees that any two objects with the same abstract value are represented by just one concrete object. Answer each part in one sentence.\
(a) Give a usage pattern (or its characteristics) in which the interning pattern uses less memory, compared to not using it, and explain why.\
A: A compiler symbol table, in which most symbols are used multiple times, so eliminating duplication saves memory.\
(b) Give a usage pattern (or its characteristics) in which the interning pattern uses more memory, compared to not using it, and explain why.\
A: A situation in which most objects have different values, so the overhead of the hash table used by the interning implementation outweighs the reduction in memory used by duplicate objects.\
(c) Give a usage pattern (or its characteristics) in which the interning pattern uses less time, compared to not using it, and explain why. Ignore effects that are really due to memory use, such as faster allocation.\
A: Interning makes comparisons complete faster (the equals method always first checks object equality), so if there are many comparisons, the speedup outweighs the time cost of interning, which is a search for an equal object.\
(d) Give a usage pattern (or its characteristics) in which the interning pattern uses more time, compared to not using it, and explain why. Ignore effects that are really due to memory use, such as thrashing.\
A: If few equality checks are performed, then the speedup does not outweigh the time cost of performing interning. The main goal of interning is to save memory, so interning can be worthwhile even if it slows down the program.

**Q36**
:maple_leaf: Explain the difference between a self-call, a synchronous callback, and an asynchronous callback. Give a concrete example of each. Draw a sequence diagram for each, and explicitly mark the self-call or callback in each (one marked call in each).\

![C1](https://user-images.githubusercontent.com/54834769/210238054-6e6303c3-62f3-4d8a-a125-8ac244e647c3.JPG)
![C2](https://user-images.githubusercontent.com/54834769/210238080-7c89c836-a79c-4ad1-827c-c0478c774298.JPG)
![C3](https://user-images.githubusercontent.com/54834769/210238091-33ff7e09-993e-43ef-ba03-6611f8796c3e.JPG)



**Q37**
:maple_leaf: Waterfall modelini açıklayınız.
A: Gereksinim Analizi -> Sistem ve Yazılım Tasarımı -> Gerçekleme ve Birim Testler -> Entegrasyon ve Sistem Testleri -> Operasyon ve Sistem Devamlılığı\
Değişime karşı yavaş reaksiyon verilir.

**Q38**
:maple_leaf: Yazılım Mühendisliği nedir?
A: Yazılım geliştirmenin tüm yönleri ve boyutları ile ilgilenen disipline verilen isimdir.

**Q39**
:maple_leaf: Incremantal Yazılım Geliştirme nedir?
A: Tamamlanmamış versiyonlar arasında refactoring vb yöntemler ile yazılım extarnal (dış) davranışını değiştirmeden iç yapısında (internal) geliştirme yapılır.

**Q40**
:maple_leaf: Yazılım uygulama çeşitleri nelerdir? Örnekler ile açıklayınız.
A: Stand-alone applications:These are application systems that run on a local computer, such as a PC. They include all necessary functionality and do not need to be connected to a network.\
Interactive transaction-based applications: Applications that execute on a remote computer and are accessed by users from their own PCs or terminals. These include web applications such as e-commerce applications.\
Embedded control systems: These are software control systems that control and manage hardware devices. Numerically, there are probably more embedded systems than any other type of system.\
Batch processing systems: These are business systems that are designed to process data in large batches. They process large numbers of individual inputs to create corresponding outputs.\
Data collection systems: These are systems that collect data from their environment using a set of sensors and send that data to other systems for processing.


**Q41**
:maple_leaf:

**Q42**
:maple_leaf:

**Q43**
:maple_leaf:

**Q44**
:maple_leaf:

**Q45**
:maple_leaf:


<a href="#top">Back to top</a>

## :dvd: 08 Veritabanı ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :factory: 09 Bilgisayar Mimarisi ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>

## :sparkles: 10 Yapay Zeka ##

    .
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    ├── 
    └── 

<a href="#top">Back to top</a>


## :memo: Lisans ##

This project is under license from MIT. For more details, see the [LICENSE](LICENSE) file.


Made with :heart: by <a href="https://github.com/otahsinb" target="_blank">otahsinb</a>

&#xa0;

<a href="#top">Back to top</a>
